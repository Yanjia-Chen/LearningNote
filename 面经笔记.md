# Java基础

## 集合

### 列表

- ArrayList VS LinkedList

  | ArrayList                      | LinkedList             |
  | ------------------------------ | ---------------------- |
  | 数组                           | 双向链表               |
  | 增删慢，通过下标查询快         | 增删快，通过下标查询慢 |
  | 当数组无法容纳新增内容时，扩容 | 无                     |
  | 扩容后的容量是原来的1.5倍      | 无                     |

### Map

#### HashMap

- 实现思路：
  - JDK1.8前：数组+链表。极端情况下，所有元素会在一个链表里面，效率差。
  - JDK1.8后：数组+红黑树

- HashMap为何线程不安全？

  - jdk1.7中采用**表头插入法**，在扩容时会**改变**链表中元素原本的顺序，以至于在并发场景下导致链表成环的问题。
  - 在jdk1.8中采用的是**尾部插入法**，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。

- 容量的默认大小是 16，负载因子是 0.75，当 HashMap 的 size > 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。如果能提前估算出数据规模，可以先设置Map的大小，避免触发扩容操作。

- Map的容量都是2^n。原因是，根据HashCode寻找数组中对应元素时，需要对HashCode取模。而普通的取模运算效率低，但如果除数是2的N次方，那么取模运算等效于和(2^n)-1进行与操作，提高取模效率。

  - 为什么当除数是2^n时，取模运算等效于和(2^n)-1进行与操作呢？

    ```
    假设被除数为X。那么X除以2^n等价与将X的二进制右移n位，即X>>n。
    那么X除以2^n的余数，其实就是X的最后n位。
    而(2^n)-1的二进制为011...111，0后面又n个1。
    那么X和(2^n)-1进行与操作，就能将X的最后n位算出来，得到的就是余数，及模运算的结果。
    ```

    

#### HashTable

- 数组+链表实现
- 继承自Dictionary类，但这个类已经被弃用了。
- 线程安全，每个方法都通过synchronized加锁，效率低。
- 不支持null key和null value
- 初始大小为11，用户可以自己指定大小。



#### ConcurruntHashMap

- Java7，分段锁？



## 并发编程

### 三个核心概念

- 原子性

  一个操作，要么全部执行成功，要么全部不执行。

  - 经典例子：

    银行转账时，账户修改必须保证原子性。

  - 如何保证原子性：

    - 用同步锁
    - 用同步代码块（syncronized）
    - 使用Java提供的一些原子操作类，如AtomicInteger

- 可见性

  多线程并发访问**共享变量**时，一个线程对共享变量进行了修改，其他线程能立即看到。

  - 原因：目前的计算机中，都会存在多级缓存。每个线程去读取共享变量的时候，会将从主存中加载到缓存中。但一旦修改了共享变量时，缓存中的数据立即刷新了，但比一定会立即更新主存上的数据，导致其他线程不饿能及时获取最新的数据。
  - 如何保证可见性：
    - 使用volatile关键字
    - 锁和synchronized关键字

- 顺序性

  指的时程序执行的顺序，按照代码的先后顺序执行。

  - 原因：JVM执行命令时，会进行优化，导致各命令的执行顺序发生变化。但会保证单线程情况下的执行结果和调整前一样，但不保证多线程情况的执行正确性。
  - happens-before原则：若两个操作满足happens-before原则，JVM会保证其顺序性。



### synchronized的几种用法

TODO



### 锁

TODO





## 线程池





# Web框架

## Spring





## 微服务



# 数据库







# 中间件

## ZooKeeper



## Kafka





## Redis





# 设计模式

TODO

